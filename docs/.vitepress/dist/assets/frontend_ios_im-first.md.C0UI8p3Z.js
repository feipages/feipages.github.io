import{_ as e,c as a,o as r,ag as o}from"./chunks/framework.BHpayLOB.js";const u=JSON.parse('{"title":"IM Introduction","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/ios/im-first.md","filePath":"frontend/ios/im-first.md"}'),d={name:"frontend/ios/im-first.md"};function i(n,t,l,c,s,h){return r(),a("div",null,t[0]||(t[0]=[o('<h1 id="im-introduction" tabindex="-1">IM Introduction <a class="header-anchor" href="#im-introduction" aria-label="Permalink to &quot;IM Introduction&quot;">​</a></h1><h2 id="im-即时通讯技术-介绍" tabindex="-1">IM 即时通讯技术 介绍 <a class="header-anchor" href="#im-即时通讯技术-介绍" aria-label="Permalink to &quot;IM 即时通讯技术 介绍&quot;">​</a></h2><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><p>即时通信的常用应用场景：即实时性要求高的场景，常见的如下： 视频会议、聊天、私信 弹幕、抽奖 互动游戏 协同编辑 股票基金实时报价、体育实况更新、 基于位置的应用：Uber、滴滴司机位置 在线教育 智能家居</p><h3 id="基本的发展阶段" tabindex="-1">基本的发展阶段 <a class="header-anchor" href="#基本的发展阶段" aria-label="Permalink to &quot;基本的发展阶段&quot;">​</a></h3><p>轮询-》长轮询-》长连接</p><p>注意长短连接与长短轮询的区别 概念范畴：长短轮询是应用层概念、长短连接是传输层概念 协商方式：一个 TCP 连接是否为长连接，是通过设置 HTTP 的 Connection Header 来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。 实现方式：连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的</p><h3 id="数据传输格式" tabindex="-1">数据传输格式 <a class="header-anchor" href="#数据传输格式" aria-label="Permalink to &quot;数据传输格式&quot;">​</a></h3><p>自定义二进制 开源协议：protocol buffers 文本协议(json\\xml)</p><h3 id="常见的实现方式" tabindex="-1">常见的实现方式 <a class="header-anchor" href="#常见的实现方式" aria-label="Permalink to &quot;常见的实现方式&quot;">​</a></h3><ol><li>基于Scoket：代表框架:CocoaAsyncSocket</li><li>基于WebScoket: SocketRocket</li><li>基于MQTT: MQTTKit</li><li>基于XMPP: XMPPFramework</li></ol><table tabindex="0"><thead><tr><th>名称</th><th>协议举例</th><th style="text-align:center;">优点</th><th style="text-align:center;">缺点</th></tr></thead><tbody><tr><td>Socket</td><td>Socket+protocol buffers</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td>WebScoket</td><td>WebScoket+json</td><td style="text-align:center;">高效、节约流量(比如使用protocol buffers，或压缩json格式),ios Android web三端通用</td><td style="text-align:center;">对设计者要求高</td></tr><tr><td>MQTT</td><td></td><td style="text-align:center;">协议简单，流量少、订阅+推送模式</td><td style="text-align:center;">并不是专门为IM设计的协议，多用于推送</td></tr><tr><td>XMPP</td><td>Scoket+xml</td><td style="text-align:center;">开源、可扩展性强、方便接入</td><td style="text-align:center;">XML表现力差、额外信息多、流量耗费大</td></tr></tbody></table><h3 id="重连机制" tabindex="-1">重连机制 <a class="header-anchor" href="#重连机制" aria-label="Permalink to &quot;重连机制&quot;">​</a></h3><table tabindex="0"><thead><tr><th>TCP KeepAlive机制</th><th>心跳机制</th></tr></thead><tbody><tr><td>检测连接的状态</td><td>检测通信双方的存活状态</td></tr><tr><td>在定时的时间（一般为7200s）到后， 发送相应的KeepAlive探针，</td><td></td></tr><tr><td>失败后重试10次，每次超时时间75s</td><td>通常可设置3-5min发Ping</td></tr></tbody></table><p>date: 2017-11-27 16:00:00 author: &quot;Gao Fei&quot;</p>',15)]))}const m=e(d,[["render",i]]);export{u as __pageData,m as default};
